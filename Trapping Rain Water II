/*
Problem Statement:: 
Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.

Example 1:
Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
Output: 4
Explanation: After the rain, water is trapped between the blocks.
We have two small ponds 1 and 3 units trapped.
The total volume of water trapped is 4.

Example 2:
Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
Output: 10

Constraints:
m == heightMap.length
n == heightMap[i].length
1 <= m, n <= 200
0 <= heightMap[i][j] <= 2 * 104
*/
class Solution {
    public int trapRainWater(int[][] heightMap) 
    {
        int m=heightMap.length;
        int n=heightMap[0].length;
        int waterConsume=0;
        int[][] dir={{0,-1},{0,1},{-1,0},{1,0}};
        //This priorityqueue will store height and coordinate and will sort based on height.
        //First with this approach, will insert all boundary cells into PriorityQueue as they can't water, then for inside will pop PriorityQueue, and check if it is less than in height with other surrodings cell it will consider to store the water, will add in waterconsume variable and return it at last
        PriorityQueue<int[]> boundryCells=new PriorityQueue<>(Comparator.comparingInt(a->a[0])); //to sort based on height
        boolean[][] visited =new boolean[m][n];
        //Now traverse through the left and right col wala boundary cells
        for(int row=0;row<m;row++)
        {
            //So col we need to consider cell as col value (0,n-1) only
            boundryCells.offer(new int[]{heightMap[row][0],row,0}); //for 0 col value
            boundryCells.offer(new int[]{heightMap[row][n-1],row,n-1}); //for n-1 col value
            visited[row][0]=true;
            visited[row][n-1]=true;
        }
        //Similarly for row=0 & row=m-1 which are boundary cell we nned to compute
         for(int col=0;col<n;col++)
        {
            //So col we need to consider cell as col value (0,n-1) only
            boundryCells.offer(new int[]{heightMap[0][col],0,col}); //for 0 col value
            boundryCells.offer(new int[]{heightMap[m-1][col],m-1,col}); //for n-1 col value
            visited[0][col]=true;
            visited[m-1][col]=true;
        }
        //Now we need to check if until PriorityQueue is empty will pull the value which is minimum at height, and check for it's neighbour in order to understand how much water it will consume and add it to he Water consume variable, at last will return the waterConsume
        while(!boundryCells.isEmpty())
        {
            int[] cell=boundryCells.poll();
            int height=cell[0];
            int i=cell[1]; //this is current cell
            int j=cell[2];

            //now move through four directions of this (i,j) cell
            //Explore
            for(int[]d:dir)
            {
                int i_=i+d[0];
                int j_=j+d[1];
            if(i_>=0 && i_<m && j_>=0 && j_<n && !visited[i_][j_])
            {
                waterConsume+=Math.max(height-heightMap[i_][j_],0);
                boundryCells.offer(new int[]{Math.max(height,heightMap[i_][j_]),i_,j_});
                visited[i_][j_]=true;
            }
         }
     }
       return waterConsume;
    }
}
//TC:O(m*n*log(m*n))
//SC:O(m*n)
