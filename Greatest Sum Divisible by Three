/*
Problem Description: Given an integer array nums, return the maximum possible sum of elements of the array such that it is divisible by three.
Example 1:
Input: nums = [3,6,5,1,8]
Output: 18
Explanation: Pick numbers 3, 6, 1 and 8 their sum is 18 (maximum sum divisible by 3).
Example 2:
Input: nums = [4]
Output: 0
Explanation: Since 4 is not divisible by 3, do not pick any number.
Example 3:
Input: nums = [1,2,3,4,4]
Output: 12
Explanation: Pick numbers 1, 3, 4 and 4 their sum is 12 (maximum sum divisible by 3).

Constraints:
1 <= nums.length <= 4 * 104
1 <= nums[i] <= 104

class Solution {
    public int maxSumDivThree(int[] nums) 
    {
        int n=nums.length;
        /*
    Approach: It is possible that divided by 3 could have 3 types of reminder, either 0,1 or 2,if it is 0 then return it, if 1 then there would be 2 things we can do! 
    if: reminder is 1:
    then,1)check the one number that is giving reminder as 1 and remove that only(as we want to get max sum out of it so will focus to remove min no possible)
    2)If there is no any one direct number which could give reminder as one, then find two numbers which are giving reminder as 2, then sum those two number the reminder would always be one!

     else if reminder is 2:
     then , 1) Find out the one number which is giving reminder two
     2) or, find out such two numbers which is giving reminder as 1, and then sum them up(which will always give reminder as 2)
     And for both cases reminder 1 or reminder 2 we need to sort the array which is storing the reminder 1 and reminder 2 values itself(while traversing num array and divided by 3)
        */
    List<Integer> reminder1=new ArrayList();
    List<Integer> reminder2=new ArrayList();
    int sum=0;
    for(int i=0;i<n;i++)
    {
        sum+=nums[i];
     //Now consider reminder=1 and reminder=2 cases,
     if(nums[i]%3==1)
     {
        reminder1.add(nums[i]);
     }
     else if(nums[i]%3==2)
     {
        reminder2.add(nums[i]);
     }
   }
      if(sum%3==0) //Best case
        {
            return sum;
        }
     Collections.sort(reminder1);
     Collections.sort(reminder2);
     int result=0;

     if(sum%3==1)
     {
        int remove1=reminder1.size()>0 ?reminder1.get(0) :Integer.MAX_VALUE;// The only number which is giving reminder as 1
        int remove2=reminder2.size()>1 ?reminder2.get(0)+reminder2.get(1) :Integer.MAX_VALUE;
        result=Math.max(result,sum-Math.min(remove1,remove2));
     }
     else
     {
        //reminder is two
        int remove1=reminder2.size()>0 ?reminder2.get(0) :Integer.MAX_VALUE;// The only number which is giving reminder as 1
        int remove2=reminder1.size()>1 ?reminder1.get(0)+reminder1.get(1) :Integer.MAX_VALUE;
        result=Math.max(result,sum-Math.min(remove1,remove2));
     }
    return result;
    }
}
//TC:O(nlog(n))
//SC:O(N)

//Approach 2: DP(Top Down)
{
public int maxSumDivThree(int[] nums) 
    { 
      int[][] dp=new int[nums.length][3]; //here two things are changing index, and rem as rem can be 0,1,2 hence 3 is the size we take
    for(int i=0;i<dp.length;i++)
    {
        for(int j=0;j<dp[0].length;j++)
        {
            dp[i][j]=-1;
        }
    }

      return solve(0,0,nums,dp);
    }
    private static int solve(int i,int rem,int[] nums,int[][] dp)
    {
        if(i>=nums.length)
        {
           if(rem==0)
           {
             return 0;
           }
          return Integer.MIN_VALUE;
        }
        if(dp[i][rem]!=-1)
        {
            return dp[i][rem];
        }
        
        int take=nums[i]+solve(i+1,(rem+nums[i])%3,nums,dp);
        int skip=solve(i+1,rem,nums,dp);
        return dp[i][rem]=Math.max(take,skip);
    }
}


