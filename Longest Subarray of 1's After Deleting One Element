/*
Problem Statement:
Given a binary array nums, you should delete one element from it.Return the size of the longest non-empty subarray containing only 1's in the resulting array. Return 0 if there is no such subarray.
Example 1:
Input: nums = [1,1,0,1]
Output: 3
Explanation: After deleting the number in position 2, [1,1,1] contains 3 numbers with value of 1's.

Example 2:
Input: nums = [0,1,1,1,0,1,1,0,1]
Output: 5
Explanation: After deleting the number in position 4, [0,1,1,1,1,1,0,1] longest subarray with value of 1's is [1,1,1,1,1].

Example 3:
Input: nums = [1,1,1]
Output: 2
Explanation: You must delete one element.
 
Constraints:
1 <= nums.length <= 105
nums[i] is either 0 or 1.

*/
   class Solution {
    public int longestSubarray(int[] nums) 
    {
        //Approach3 : Better Sliding window , as one zero is window here will store last_seen_zero_index , and once zerocount>1 then we shift i to last_seen_zero_index+1
        //TC:O(N) //SC:O(1)
        int n=nums.length;
        int i=0;
        int j=0;
        int result=0;
        int lastSeenZeroIndex=-1;
        while(j<n)
        {
          if(nums[j]==0)
          {
            i=lastSeenZeroIndex+1;          
            lastSeenZeroIndex=j;
          }
          result=Math.max(result,j-i);
         j++;
    }
     return result;
    }
   }
    
        //Approach 2: Sliding Window:  If seen more than one zero shrink window else keep going(j)
        //TC:O(N+N)~TC:O(N) //SC:O(1)
        int n=nums.length;
        int i=0;
        int j=0;
        int result=0;
        int zeroCount=0;
        while(j<n)
        {
          if(nums[j]==1)
          {
             result=Math.max(result,j-i);  //as we have to delete one element hence instead of j-i+1 window count is j-i
          }
          else
          {
            zeroCount++;
          }
          while(zeroCount>1)
          {
            //Window shrink
            if(nums[i]==0)
            {
                zeroCount--;
            }
            i++;
            result=Math.max(result,j-i); 
          }
          j++;
        }
       return result;
    }
   } 

       //Brute Force: Check for each zero position and skip it and calculate the rest subarray length, return max out of it
       //TC:O(N^2)=> Time Limit Exceed
       int n=nums.length;
       int maxVal=0;
       int zeroCount=0;
       for(int i=0;i<n;i++)
       {
         if(nums[i]==0)
         {
            zeroCount++;
            maxVal=Math.max(maxVal,findSubArray(nums,i));
         }
       }
       if(zeroCount==0)
       {
        return n-1;
       }
      return maxVal;       
    }
    private  int findSubArray(int[] nums,int index)
    {
        int currLen=0;
        int maxLen=0;
        int n=nums.length;
        for(int i=0;i<n;i++)
        {
            if(i==index)
            {
                continue;
            }
            if(nums[i]==1)
            {
               currLen++; 
               maxLen=Math.max(maxLen,currLen);
            }
            else
            {
                currLen=0;
            }
        }
        return maxLen;
    }
}
