/*
Problem Statement:: You are given an array of n strings strs, all of the same length.We may choose any deletion indices, and we delete all the characters in those indices for each string.
For example, if we have strs = ["abcdef","uvwxyz"] and deletion indices {0, 2, 3}, then the final array after deletions is ["bef", "vyz"].Suppose we chose a set of deletion indices answer such that after deletions, the final array has every string (row) in lexicographic order. (i.e., (strs[0][0] <= strs[0][1] <= ... <= strs[0][strs[0].length - 1]), and (strs[1][0] <= strs[1][1] <= ... <= strs[1][strs[1].length - 1]), and so on). Return the minimum possible value of answer.length

Example 1:
Input: strs = ["babca","bbazb"]
Output: 3
Explanation: After deleting columns 0, 1, and 4, the final array is strs = ["bc", "az"].
Both these rows are individually in lexicographic order (ie. strs[0][0] <= strs[0][1] and strs[1][0] <= strs[1][1]).
Note that strs[0] > strs[1] - the array strs is not necessarily in lexicographic order.
Example 2:
Input: strs = ["edcba"]
Output: 4
Explanation: If we delete less than 4 columns, the only row will not be lexicographically sorted.
Example 3:
Input: strs = ["ghi","def","abc"]
Output: 0
Explanation: All rows are already lexicographically sorted.


Constraints:
n == strs.length
1 <= n <= 100
1 <= strs[i].length <= 100
strs[i] consists of lowercase English letters.
 
*/
class Solution {
    int[][] dp;
    public int minDeletionSize(String[] strs) {
        int n=strs.length;
        int m=strs[0].length();
        dp=new int[m+1][m];
        int maxTake= solve(strs,n,m,-1,0);
        return m-maxTake;// TotalLen-take=skip , we need to return min skip hence we need to find max take(Similar to LIS prob)
    }
    private  int solve(String[] strs, int n,int m,int prev,int curr)
    {
        //Base Condition
        if(curr==m)
        {
            return 0;
        }
        if(dp[prev+1][curr]!=0)
        {
            return dp[prev+1][curr]; 
        }
        int take=0;
        if(prev==-1|| compare(strs,n,prev,curr))
        {
            //include
             take=1+solve(strs,n,m,curr,curr+1);
        }
       //else exclude
       int skip=solve(strs,n,m,prev,curr+1);
       return dp[prev+1][curr]=Math.max(take,skip);
    }
    private boolean compare(String[] strs,int n,int prev, int curr)
    {
        //Iterate through String array
        for(int i=0;i<n;i++)
        {
             if(strs[i].charAt(prev)>strs[i].charAt(curr))
             {
                return false;
             }
        }
        return true;
    } 
}
//TC:O(m*(m+1))-> For DDP prev,curr state *O(n) for compare~TC:O(m^2.n)
//SC:O(m^2)
