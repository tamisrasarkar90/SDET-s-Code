/* Problem Description: You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times,
Select an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.Return the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.
The gcd of two integers is the greatest common divisor of the two integers.

Example 1:
Input: nums = [2,6,3,4]
Output: 4
Explanation: We can do the following operations:
- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].
- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].
- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].
- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].
Example 2:
Input: nums = [2,10,6,14]
Output: -1
Explanation: It can be shown that it is impossible to make all the elements equal to 1.
 
Constraints:
2 <= nums.length <= 50
1 <= nums[i] <= 106
*/
class Solution {
    public int minOperations(int[] nums) 
    {
        int minOps=0;
        int n=nums.length;
        int oneCount=0;
        int g=0;
       
        // Two Observation while solving it greedily 1) If there is number 1 in nums array then result=nums.elngth-oneCunt
     //   2) if compute gcd of total nums array is geater then 1 then it is not possible to make the array elemnet as 1
//Approach: Greedy will work and n=50 so, n^2 solution will work, incase there is 
//currently no one in the subarray then we need to consider evalute subarray with minLength can have a 
//1 after gcd replacement, why min length as min length subarray will consume min operations to make aubarray as 1, 
//and then the answer is n-countOfOne here countOfOne is (minLength-1) as in the minLength subarray one element is already 1 so remiaing needs to convert to one 
//is (minLength-1), similary I am considering in nlength array, 1 elemnent has already converted so remaining element is n-1, 
//hence the result would be (minlength-1)+(n-1)=> minLength+n-2
     for(int num:nums)
     {
        if(num==1)
        {
            oneCount++;
        }
        g=gcd(g,num);
     }
     if(oneCount>0)
     {
        return n-oneCount;
     }
     if(g>1)
     {
        return -1;
     }
     int minLen=n;
     // Now evaluate minLength subArray whose gcd is 1 and the result is minLength+n-2;
        for(int i=0;i<n;i++)
        {
            int currentGcd=0;
            for(int j=i;j<n;j++)
            {
              currentGcd=gcd(currentGcd,nums[j]);
              if(currentGcd==1) //then we found minLength subArray gcd as 1
              {
                 minLen=Math.min(minLen,j-i+1);
                 break;
              }
            }
        }
      return minLen+n-2;
    }
    private int gcd(int a,int b)
    {
        if(b==0)
        {
            return a;
        }
      return gcd(b,a%b);
    }
}
//TC:O(N^2LogM) //SC:O(1) => gcd takes logM times N^2 is to find the subarray
