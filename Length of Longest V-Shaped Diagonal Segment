/*
Problem Statement:
You are given a 2D integer matrix grid of size n x m, where each element is either 0, 1, or 2.A V-shaped diagonal segment is defined as:
The segment starts with 1.
The subsequent elements follow this infinite sequence: 2, 0, 2, 0, ....
The segment:
Starts along a diagonal direction (top-left to bottom-right, bottom-right to top-left, top-right to bottom-left, or bottom-left to top-right).
Continues the sequence in the same diagonal direction.
Makes at most one clockwise 90-degree turn to another diagonal direction while maintaining the sequence.
Return the length of the longest V-shaped diagonal segment. If no valid segment exists, return 0.

Example 1:
Input: grid = [[2,2,1,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]
Output: 5
Explanation:
The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,2) → (1,3) → (2,4), takes a 90-degree clockwise turn at (2,4), and continues as (3,3) → (4,2).

Example 2:
Input: grid = [[2,2,2,2,2],[2,0,2,2,0],[2,0,1,1,0],[1,0,2,2,2],[2,0,0,2,2]]
Output: 4
Explanation:
The longest V-shaped diagonal segment has a length of 4 and follows these coordinates: (2,3) → (3,2), takes a 90-degree clockwise turn at (3,2), and continues as (2,1) → (1,0).

Example 3:
Input: grid = [[1,2,2,2,2],[2,2,2,2,0],[2,0,0,0,0],[0,0,2,2,2],[2,0,0,2,0]]
Output: 5
Explanation:
The longest V-shaped diagonal segment has a length of 5 and follows these coordinates: (0,0) → (1,1) → (2,2) → (3,3) → (4,4).

Example 4:
Input: grid = [[1]]
Output: 1
Explanation:
The longest V-shaped diagonal segment has a length of 1 and follows these coordinates: (0,0).

Constraints:
n == grid.length
m == grid[i].length
1 <= n, m <= 500
grid[i][j] is either 0, 1 or 2.

*/
class Solution {
    int[][] dir={{1,1},{1,-1},{-1,-1},{-1,1}};   
    int m=0;
    int n=0;
    int[][][][]dp;
    public int lenOfVDiagonal(int[][] grid) 
    {
        m=grid.length;
        n=grid[0].length;
        int result=0;
        int val=0;
        dp=new int[m][n][4][2];
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                for(int d=0;d<4;d++)
                {
                  for(int c=0;c<2;c++)
                  {
                     dp[i][j][d][c]=-1;
                  }
                }
            }
        }
        //We can move from cell==1 to 4 directions,(1,1),(1,-1),(-1,1),(-1,-1) while traversing througha diagonal and then move to 90 degree(at most one)
        for(int i=0;i<m;i++)
        {
            for(int j=0;j<n;j++)
            {
                if(grid[i][j]==1) //If we get cell value as 1 then we can start traversing
                {
                   for(int d=0;d<=3;d++)
                   {                   
                     result=Math.max(result,1+solve(i,j,d,1,grid,2)); //as after 1 we need to pass 2 only and as we need to include 1(i,j=>1) jence 1+solve()
                    }
                }
            }
        }
        return result;       
    }
    private  int solve(int i, int j,int d,int canTurn,int[][]grid,int val)
    {
        int _i=i+dir[d][0];
        int _j=j+dir[d][1];
        if(_i<0 ||_i>=m ||_j<0|| _j>=n ||grid[_i][_j]!=val)
        {
          return 0;
        }
        if(dp[_i][_j][d][canTurn]!=-1)
        {
            return dp[_i][_j][d][canTurn];
        }
        int nextVal = (val == 2 ? 0 : 2);
        int result=0;
        int keepMoving=1+solve(_i,_j,d,canTurn,grid,nextVal);
        result=Math.max(result,keepMoving);
        if(canTurn==1)
        {
          int turnAndKeepMoving= 1+solve(_i,_j,(d+1)%4,0,grid,nextVal); //(d+1)%4 as after (-1,1) it will return to (1,1)
          result=Math.max(result,turnAndKeepMoving);
        }
                
        return   dp[_i][_j][d][canTurn]=result;
          
    }
}
//TC:O(m*n)
//SC:O(m*n)
