/* Problem Statement:
You are given a 2D array points of size n x 2 representing integer coordinates of some points on a 2D plane, where points[i] = [xi, yi].Count the number of pairs of points (A, B), where
A is on the upper left side of B, and
there are no other points in the rectangle (or line) they make (including the border).
Return the count.

Example 1:
Input: points = [[1,1],[2,2],[3,3]]
Output: 0
Explanation:
There is no way to choose A and B so A is on the upper left side of B.

Example 2:
Input: points = [[6,2],[4,4],[2,6]]
Output: 2
Explanation:
The left one is the pair (points[1], points[0]), where points[1] is on the upper left side of points[0] and the rectangle is empty.
The middle one is the pair (points[2], points[1]), same as the left one it is a valid pair.
The right one is the pair (points[2], points[0]), where points[2] is on the upper left side of points[0], but points[1] is inside the rectangle so it's not a valid pair.

Example 3:
Input: points = [[3,1],[1,3],[1,1]]
Output: 2
Explanation:
The left one is the pair (points[2], points[0]), where points[2] is on the upper left side of points[0] and there are no other points on the line they form. Note that it is a valid state when the two points form a line.
The middle one is the pair (points[1], points[2]), it is a valid pair same as the left one.
The right one is the pair (points[1], points[0]), it is not a valid pair as points[2] is on the border of the rectangle.
 

Constraints:
2 <= n <= 50
points[i].length == 2
0 <= points[i][0], points[i][1] <= 50
All points[i] are distinct.
*/
class Solution {
    public int numberOfPairs(int[][] points)
    {
        //Approach 2: Sorting : TC:O(N^2+logN)~TC:O(N^2) //SC:O(1)

        int n=points.length;
        int result=0;
       
        Arrays.sort(points,(point1,point2)->{
            if(point1[0]==point2[0]) //if (x2==x1) the sort decending order of y
            {
                return point2[1]-point1[1];
            }
            return point1[0]-point2[0];
        });
        for(int i=0;i<n;i++)
        {
            int x1=points[i][0]; //Now we need not to check for xpairs as it is already sorted
            int y1=points[i][1];
            int maxY=Integer.MIN_VALUE;
            for(int j=i+1;j<n;j++)
            {             
                int x2=points[j][0];
                int y2=points[j][1];
             //check for any pairs in between, for that we need to check the Y corordinate only, if the lesser Y corordinate also above of the maxY point then there is no points inside or boarder of the rectangle
                if(y2>y1)
                {
                    continue;
                }
                if(y2>maxY)
                {
                    result++; //we got  avalid rectangle
                    maxY=y2;
                }               
            }       
        }
       return result;
    }
}
   

/*
        //Approach 1: Brute Force
        int n=points.length;
        int result=0;
        for(int i=0;i<n;i++)
        {
            int x1=points[i][0];
            int y1=points[i][1];

            for(int j=0;j<n;j++)
            {
                if(i==j)
                {
                    continue; //the same point will not consider for (x1,y1) & (x2,y2)
                }
                int x2=points[j][0];
                int y2=points[j][1];
                //condition to create valid rectangle
                if(x2>=x1 && y1>=y2) //(x1,y1) is in top and (x2,y2) is in bottom right
                {
                    boolean insidePoint=false;
                    //now check if any (x3,y3) is lying inside the rectangle or even within the border of teh rectangle
                    for(int k=0;k<n;k++)
                    {
                        if(k==i|| k==j)
                        {
                            continue;
                        }
                        int x3=points[k][0];
                        int y3=points[k][1];
                        if(x3>=x1 && x3<=x2 && y3<=y1 && y3>=y2)
                        {
                              insidePoint=true;
                              break;
                        }
                    }
                   if(insidePoint==false)
                   {
                    result++;
                   }
                }

            }
        }
       return result;
    }
}
//TC:O(N^2*K)
//SC:O(1)
*/
