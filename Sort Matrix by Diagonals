/*
Problem Description::
You are given an n x n square matrix of integers grid. Return the matrix such that:
The diagonals in the bottom-left triangle (including the middle diagonal) are sorted in non-increasing order.
The diagonals in the top-right triangle are sorted in non-decreasing order.
 
Example 1:
Input: grid = [[1,7,3],[9,8,2],[4,5,6]]
Output: [[8,2,3],[9,6,7],[4,5,1]]
Explanation:
The diagonals with a black arrow (bottom-left triangle) should be sorted in non-increasing order:
[1, 8, 6] becomes [8, 6, 1].
[9, 5] and [4] remain unchanged.
The diagonals with a blue arrow (top-right triangle) should be sorted in non-decreasing order:
[7, 2] becomes [2, 7].
[3] remains unchanged.

Example 2:
Input: grid = [[0,1],[1,2]]
Output: [[2,1],[1,0]]
Explanation:
The diagonals with a black arrow must be non-increasing, so [0, 2] is changed to [2, 0]. The other diagonals are already in the correct order.

Example 3:
Input: grid = [[1]]
Output: [[1]]
Explanation:
Diagonals with exactly one element are already in order, so no changes are needed.

Constraints:
grid.length == grid[i].length == n
1 <= n <= 10
-105 <= grid[i][j] <= 105

*/
class Solution {
    public int[][] sortMatrix(int[][] grid) 
    {
        int n=grid.length;
        
       //Approach1: Brute Force: Including the mid diagonal, in all bottom-left triangle row is starting from 0 and chnaging while col is fixed, will traverse likewise(strating from row 0-> row++ and col++) and get those elements and sort it and push it back to the grid . similarly for top right triangle will see row is fixed col is changing , will take those elemnets and sort in increasing order and push it back.
      //For Bottom left triangle-> row is changing,col is fixed
       for(int row=0;row<n;row++)
       {
           solve(row,0,grid,1);
       }

       //For Top right triangle-> col is changing,row is fixed
       for(int col=1;col<n;col++)
       {
           solve(0,col,grid,0);
       }
       return grid;
    }
    private void solve(int row, int col, int[][]grid,int decre)
    {
         int n=grid.length;
         int i=row;
         int j=col;
         
         List<Integer> list=new ArrayList();
         while(i<n && j<n)
         {           
            list.add(grid[i][j]); //i++ & j++;will give ypu elements on that doagonal
            i++;
            j++;
         }
         if(decre==1)  //sort decreasingly i.e Bottom left
         {
           Collections.sort(list,Collections.reverseOrder());
         }
         else
         {
            Collections.sort(list);
         }

         //Once the list is sorted we need to push it back to grid
         int k=row;
         int l=col;
         for(int val:list)
         {
            grid[k][l]=val;
            k++;
            l++;
         }
    }

}
