/*
Problem Statement:
Given a positive integer k, you need to find the length of the smallest positive integer n such that n is divisible by k, and n only contains the digit 1.Return the length of n. If there is no such n, return -1.
Note: n may not fit in a 64-bit signed integer.
Example 1:
Input: k = 1
Output: 1
Explanation: The smallest answer is n = 1, which has length 1.
Example 2:
Input: k = 2
Output: -1
Explanation: There is no such positive integer n divisible by 2.
Example 3:
Input: k = 3
Output: 3
Explanation: The smallest answer is n = 111, which has length 3.

Constraints:
1 <= k <= 105
*/
class Solution {
    public int smallestRepunitDivByK(int k) 
    {
        if(k==1)
        {
            return 1;
        }
        if(k%2==0 || k%5==0)
        {
            return -1;
        }
        int reminder=0;
        int len=1;
        
        for(;len<=k ;len++)
        {
          reminder=(reminder*10+1)%k;
           if(reminder==0)
           {
             break;            
           }
        }
        return len;
    }
}
//TC:O(N) //SC:O(1)
/*
Approach: If k is factor of 2 or 5 reminder will not be zero, so return -1, so we actually checking here 
       oldNum*10+1 is divisible by k or not if not then oldNum=oldNum*10+1 and repeat the process, as it could introduce overflow hence we are not storing oldNum instead we will store only reminder, and repeat the process, will increase length each time we get reminder !=0, and when we get reminder =0 by dividing with %k will return the length
*/
