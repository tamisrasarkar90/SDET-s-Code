/*
Problem Statement:
Given a positive integer n, there exists a 0-indexed array called powers, composed of the minimum number of powers of 2 that sum to n. The array is sorted in non-decreasing order, and there is only one way to form the array.
You are also given a 0-indexed 2D integer array queries, where queries[i] = [lefti, righti]. Each queries[i] represents a query where you have to find the product of all powers[j] with lefti <= j <= righti.
Return an array answers, equal in length to queries, where answers[i] is the answer to the ith query. Since the answer to the ith query may be too large, each answers[i] should be returned modulo 109 + 7.

Example 1:

Input: n = 15, queries = [[0,1],[2,2],[0,3]]
Output: [2,4,64]
Explanation:
For n = 15, powers = [1,2,4,8]. It can be shown that powers cannot be a smaller size.
Answer to 1st query: powers[0] * powers[1] = 1 * 2 = 2.
Answer to 2nd query: powers[2] = 4.
Answer to 3rd query: powers[0] * powers[1] * powers[2] * powers[3] = 1 * 2 * 4 * 8 = 64.
Each answer modulo 109 + 7 yields the same answer, so [2,4,64] is returned.

Example 2:
Input: n = 2, queries = [[0,0]]
Output: [2]
Explanation:
For n = 2, powers = [2].
The answer to the only query is powers[0] = 2. The answer modulo 109 + 7 is the same, so [2] is returned.
 
Constraints:
1 <= n <= 109
1 <= queries.length <= 105
0 <= starti <= endi < powers.length
*/
class Solution {
    int M=1000000007;
    public int[] productQueries(int n, int[][] queries) 
    {
        List<Long> power=new ArrayList();
        int len=queries.length;
        List<Integer> answer=new ArrayList();
        int index=0;
        //to build power array
        for(int i=0;i<32;i++)
        {
            if((n &(1<<i))!=0) // means i's bit is a set bit
            {
                power.add((long)(1<<i)); //we can write it as Math.pow(2,i), as the bit is set will consider as it is contributing to power array
            }
        }
        //Now traverse through query array
        for(int[] query:queries)
        {
            int start=query[0];
            int end=query[1];
            long result=1;
            for(int i=start;i<=end;i++)
            {
              result= (result*power.get(i))%M;
            }
            answer.add((int)result);
        }
      return answer.stream.mapToInt(i->i).toArray(); //This is just we are converting List to array with stream.
    }
}

//TC:O(Q*32)~TC:O(Q)=> where Q is the length of query array
//SC:O(1)
/*
Approach:
To form the power array is the main crux of this problem,it should be power of 2,such that it sum up to n, which is basically binrary representation of n in 32 bit format.Here we consider only the sign bit coz anyway unsign bit lead to zero.So (n&(1<<i)) is a process to check if the i th bit is sign or not ,if the answer is 1 that means the i th bit is 1 and vice versa. And then we consider only those ith bit which is sign to the power array.Once the power array is formed then we simply traverse through queries array and from start(queries[0]) to end(queries[1]), we multiply the value with power[i] and place it on answer array and return it.

*/

*/
