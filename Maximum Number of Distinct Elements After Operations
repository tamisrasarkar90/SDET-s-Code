/*
Problem Description: You are given an integer array nums and an integer k.You are allowed to perform the following operation on each element of the array at most once:
Add an integer in the range [-k, k] to the element.Return the maximum possible number of distinct elements in nums after performing the operations.

Example 1:
Input: nums = [1,2,2,3,3,4], k = 2
Output: 6
Explanation:
nums changes to [-1, 0, 1, 2, 3, 4] after performing operations on the first four elements.

Example 2:
Input: nums = [4,4,4,4], k = 1
Output: 3
Explanation:
By adding -1 to nums[0] and 1 to nums[1], nums changes to [3, 5, 4, 4].

Constraints:
1 <= nums.length <= 105
1 <= nums[i] <= 109
0 <= k <= 109

*/
class Solution {
    public int maxDistinctElements(int[] nums, int k) 
    {
        Arrays.sort(nums);
        int count=0;
        int prev=Integer.MIN_VALUE;
        for(int i=0;i<nums.length;i++)
        {
            int currVal=nums[i]-k;
            if(prev<currVal)
            {
                prev=currVal;
                count++;
            }
            else if(prev<nums[i]+k)
                {
                     prev=prev+1;
                     count++;
                }             
        }
        return count;
    }
}
//TC:O(nlogN)+O(N)
//SC:O(N)//sorting space else SC:O(1)
       
        /*Approach1: First sort the nums array(so that all duplicate numbers are close to each other),Now take the smallest value from k and add it while traversing the num, in that case we can take help of Set, if considering the smallest k value range and adding it up with current nums[i] is already existing then we can move through k's range, one more thing, we are considering the lowest k value so that in future no value overlap, in case we can random one from k range then it can overlap .TC:O(n*2*k)+O(nlogn)
        */
        //Approach2: better than Approach 1
 /* Here instead moving through k's range we can do is, for each nums[i], calculate k's range low one i.e nums[i]-k and max one i.e nums[i]+k, now if set already consists nums[i]-k,then we can add +1 with the value of nums[i-1],providing nums[i](current) value is within limit of nums[i]+k, at last return the set size
        */
    
