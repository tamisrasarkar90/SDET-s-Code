/*
Problem Statement:
You are given a 2D array queries, where queries[i] is of the form [l, r]. Each queries[i] defines an array of integers nums consisting of elements ranging from l to r, both inclusive.In one operation, you can:
Select two integers a and b from the array.
Replace them with floor(a / 4) and floor(b / 4).
Your task is to determine the minimum number of operations required to reduce all elements of the array to zero for each query. Return the sum of the results for all queries.


Example 1:
Input: queries = [[1,2],[2,4]]
Output: 3
Explanation
For queries[0]:
The initial array is nums = [1, 2].
In the first operation, select nums[0] and nums[1]. The array becomes [0, 0].
The minimum number of operations required is 1.

For queries[1]:
The initial array is nums = [2, 3, 4].
In the first operation, select nums[0] and nums[2]. The array becomes [0, 3, 1].
In the second operation, select nums[1] and nums[2]. The array becomes [0, 0, 0].
The minimum number of operations required is 2.
The output is 1 + 2 = 3.

Example 2:
Input: queries = [[2,6]]
Output: 4
Explanation:
For queries[0]:
The initial array is nums = [2, 3, 4, 5, 6].
In the first operation, select nums[0] and nums[3]. The array becomes [0, 3, 4, 1, 6].
In the second operation, select nums[2] and nums[4]. The array becomes [0, 3, 1, 1, 1].
In the third operation, select nums[1] and nums[2]. The array becomes [0, 0, 0, 1, 1].
In the fourth operation, select nums[3] and nums[4]. The array becomes [0, 0, 0, 0, 0].
The minimum number of operations required is 4.
The output is 4.

Constraints:
1 <= queries.length <= 105
queries[i].length == 2
queries[i] == [l, r]
1 <= l < r <= 109
*/

class Solution {
    public long minOperations(int[][] queries) 
    {
        /*Approach 1: Brute Force: First traverse to each int[] query on queries, and take all the values to priorityQueue or maxheap, then take out the max two values and evaluate the no of steps to convert them to zero thus it will take min operations. As the constraints is higher it might give TLE/MLE

     Approach 2: Optimized: For Steps(aka S)=1,2,3... we need to evalue a range from L-> R where L=1 for S=1 and R=L*4-1
     for S=2 , L=L(prev)*4=> 1*4=>4 and R=L*4-1=>15, and interesting part is,
     for S=1 , L=1, R=3 so the range becomes 1-> 3 , to mark all elements in this range to zero requires 1 staeps for each elements, total operations = S*total no of elemenet
     for Steps=4 , L=64,R=L*4-1=>255 so the range becomes-> 64->255 , no of steps require to make each element to zero is 4, total operation=> 4*no of element in that range
     Thus for each query array within queries we need to evalute and then Sum of total Operation/2(As we will group two elements together)
        */
        //Approach 2:
        int n=queries.length;
        long result=0;
        
        for(int[] query:queries)
        {
            int l=query[0];
            int r=query[1];
            long ops=solve(l,r);
            result+=(ops+1)/2;         
        }
      
       return result; 
    }
    private static long solve(int l,int r)
    {
        long L=1;
        long S=1;
        long totalSteps=0;
        while(L<=r) //otherwise it will be outside of the range
        {
            long R=L*4-1;
            long start=Math.max(L,(long)l);
            long end=Math.min(R,(long)r);
            if(start<=end)
            {
              totalSteps+=(end-start+1)*S;
            }          
            S++;
            L=L*4;
        }
        return totalSteps;
    }
}
//TC:O(n*log4(r)) ~O(n*log(r)) where n=queries.length & r=max number of right side range

*/
