/*
Problem Description: You are given an array nums consisting of n prime integers.You need to construct an array ans of length n, such that, for each index i, the bitwise OR of ans[i] and ans[i] + 1 is equal to nums[i], i.e. ans[i] OR (ans[i] + 1) == nums[i].
Additionally, you must minimize each value of ans[i] in the resulting array.
If it is not possible to find such a value for ans[i] that satisfies the condition, then set ans[i] = -1.

Example 1:
Input: nums = [2,3,5,7]
Output: [-1,1,4,3]
Explanation:
For i = 0, as there is no value for ans[0] that satisfies ans[0] OR (ans[0] + 1) = 2, so ans[0] = -1.
For i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 3 is 1, because 1 OR (1 + 1) = 3.
For i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 5 is 4, because 4 OR (4 + 1) = 5.
For i = 3, the smallest ans[3] that satisfies ans[3] OR (ans[3] + 1) = 7 is 3, because 3 OR (3 + 1) = 7.
Example 2:
Input: nums = [11,13,31]
Output: [9,12,15]
Explanation:
For i = 0, the smallest ans[0] that satisfies ans[0] OR (ans[0] + 1) = 11 is 9, because 9 OR (9 + 1) = 11.
For i = 1, the smallest ans[1] that satisfies ans[1] OR (ans[1] + 1) = 13 is 12, because 12 OR (12 + 1) = 13.
For i = 2, the smallest ans[2] that satisfies ans[2] OR (ans[2] + 1) = 31 is 15, because 15 OR (15 + 1) = 31.
 
Constraints:
1 <= nums.length <= 100
2 <= nums[i] <= 109
nums[i] is a prime number.

*/
class Solution {
    public int[] minBitwiseArray(List<Integer> nums)
    {
        int[] result=new int[nums.size()];
        int index=0;
        for(int i=0;i<nums.size();i++)
        {
            int val=nums.get(i);
            boolean isFound=false;
            if(val==2)
            {
                result[index]=-1;
                index++;
                continue;
            }
            for(int j=0;j<32;j++)
            {
                //1 first check the first unset bit in nums[i], inorder to check that we need to do (nums[i] & (1<<j)) is this is 1 that means the bit is set otherwise unset
                if((nums.get(i)&(1<<j))>0)
                {
                    continue;
                }
                else
                {
                    //you got the first unset bit now check for(j-1) that ie just right bit and set it to 0
                   int target=(nums.get(i)^(1<<(j-1)));
                   isFound=true;
                   result[index]=target;
                   index++;
                   break;
                }
            }
            if(!isFound)
            {
                result[index]=-1;
            }
        }
       return result;
    }
}
//TC:O(N)
//SC:O(1)

/*
Approach: Step 1: We have to find the first unset bit traversing from right
Step 2: Now just the right set bit of this current unset bit set it as 0 and take the XOR it will give you the value we need to push to resylt array, as nums[i] as source and out target has only one bit different, which is the first unset bit's next bit should be 0 for our target and which is 1 now for nums[i]

*/
