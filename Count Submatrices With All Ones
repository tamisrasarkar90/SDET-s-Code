/*
Problem Description::
Given an m x n binary matrix mat, return the number of submatrices that have all ones.

Example 1:
Input: mat = [[1,0,1],[1,1,0],[1,1,0]]
Output: 13
Explanation: 
There are 6 rectangles of side 1x1.
There are 2 rectangles of side 1x2.
There are 3 rectangles of side 2x1.
There is 1 rectangle of side 2x2. 
There is 1 rectangle of side 3x1.
Total number of rectangles = 6 + 2 + 3 + 1 + 1 = 13.

Example 2:
Input: mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
Output: 24
Explanation: 
There are 8 rectangles of side 1x1.
There are 5 rectangles of side 1x2.
There are 2 rectangles of side 1x3. 
There are 4 rectangles of side 2x1.
There are 2 rectangles of side 2x2. 
There are 2 rectangles of side 3x1. 
There is 1 rectangle of side 3x2. 
Total number of rectangles = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24.
 
Constraints:
1 <= m, n <= 150
mat[i][j] is either 0 or 1.
*/
class Solution {
    public int numSubmat(int[][] mat) 
    {
        int m=mat.length;
        int n=mat[0].length;
        int result=0;
        int[][]answer=new int[m][n];
        //This is for precompute the one value
        
        for(int i=0;i<m;i++)
        {
            int count=0;

            for(int j=n-1;j>=0;j--)
            {
               if(mat[i][j]==1)
               {
                count++;
               }
               else
               {
                count=0;
               }
               answer[i][j]=count;
            }
        }
        //Now we need to fix the top left one pos, and move towards right and bottom to find 1 and then we will take the min of it and add to the answer
        
        for(int i=0;i<m;i++)
        {
             for(int j=0;j<n;j++)//go right
             {
                //The above has fixed top left 1
                int val=Integer.MAX_VALUE;
                for(int k=i;k<m;k++) //go bottom
                {                   
                        val=Math.min(val,answer[k][j]);//answer[k][j] precomputed
                        result+=val;
                }
             }
        }
      return result;
    }
    
}
//TC:O(m*n)*O(m) => for k ~TC:O(N^3)
//SC:O(m*n)


*/
