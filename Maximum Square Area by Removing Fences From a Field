/*
Problem Statement: There is a large (m - 1) x (n - 1) rectangular field with corners at (1, 1) and (m, n) containing some horizontal and vertical fences given in arrays hFences and vFences respectively.
Horizontal fences are from the coordinates (hFences[i], 1) to (hFences[i], n) and vertical fences are from the coordinates (1, vFences[i]) to (m, vFences[i]).
Return the maximum area of a square field that can be formed by removing some fences (possibly none) or -1 if it is impossible to make a square field.
Since the answer may be large, return it modulo 109 + 7.
Note: The field is surrounded by two horizontal fences from the coordinates (1, 1) to (1, n) and (m, 1) to (m, n) and two vertical fences from the coordinates (1, 1) to (m, 1) and (1, n) to (m, n). These fences cannot be removed.

Example 1:

Input: m = 4, n = 3, hFences = [2,3], vFences = [2]
Output: 4
Explanation: Removing the horizontal fence at 2 and the vertical fence at 2 will give a square field of area 4.
Example 2:
Input: m = 6, n = 7, hFences = [2], vFences = [4]
Output: -1
Explanation: It can be proved that there is no way to create a square field by removing fences.
 
Constraints:
3 <= m, n <= 109
1 <= hFences.length, vFences.length <= 600
1 < hFences[i] < m
1 < vFences[i] < n
hFences and vFences are unique.

*/
class Solution {
    public int maximizeSquareArea(int m, int n, int[] hFences, int[] vFences) 
    {
        int l1=hFences.length;
        int l2=vFences.length;
        int[] h=new int[l1+2]; //+2 as we need to consider distance from extreme start and extreme end, those boundray bars can't be removed but can contribute to make square
        int[] v=new int[l2+2];
        int M=1_000_000_007;;
        h[0]=1;
        v[0]=1;
        h[h.length-1]=m;
        v[v.length-1]=n;
        for(int i=0;i<hFences.length;i++)
        {
          h[i+1]=hFences[i];
        }
        for(int i=0;i<vFences.length;i++)
        {
            v[i+1]=vFences[i];
        }
        Arrays.sort(h);
        Arrays.sort(v);
        //Now we need to compute the distance between all points in the horizontal bars and verticle bars
        Set<Integer> hset=new HashSet();
        Set<Integer> vset=new HashSet();
        for(int i=0;i<h.length;i++)
        {
             for(int j=i+1;j<h.length;j++)
             {
                 hset.add(h[j]-h[i]);
             }
        }
        long maxS=0;

         for(int i=0;i<v.length;i++)
        {
             for(int j=i+1;j<v.length;j++)
             {
                 if(hset.contains(v[j]-v[i]))
                 {
                    maxS=Math.max(maxS,v[j]-v[i]);
                 }
             }
        }
        if(maxS==0)
        {
            return -1;
        }
      return (int)((maxS*maxS)%M);

    }
}
//T.C : O(h^2 + v^2 + hlogh + vlogv), h = hFences.size(), v = vFences.size()
//S.C : O(h+v)
/*
Approach: 1)First we need to get the distance between points from given array which is hFence and vFence
2) Now remember to add the starting and ending points to the newly created array
3) So our new computational data structure will consists, start pt, end pt,(1,m/1,n) and all values from hFence and vFence separetly on h & V array/list
4) Now we need to compute the distance between points in order to so for both the newly created data structure we do sorting
5)Now we compute the distance between two points in order to get the width and height, and will ignore the duplicate one so we keep those differences(/width/height) in a set, and will keep checking if width exists idf teh corresponding height also exists and vice versa, once we get max of(width*height) value will return it else will return -1;

*/
