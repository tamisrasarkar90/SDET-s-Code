/*
Problem Statement: 
Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.
Assume the environment does not allow you to store 64-bit integers (signed or unsigned).

Example 1:
Input: x = 123
Output: 321

Example 2:
Input: x = -123
Output: -321

Example 3:
Input: x = 120
Output: 21

Constraints:
-231 <= x <= 231 - 1
*/
/*class Solution {    
        long MAX_VAL=(long)Math.pow(2,31);
        long MIN_VAL=-(long)Math.pow(2,31);
    public int reverse(int x) 
    {
        String s=String.valueOf(x);
        StringBuilder st=new StringBuilder(s);
        StringBuilder revS=new StringBuilder();
        revS=st.reverse();
        if(x<0)
        {
            revS.deleteCharAt(revS.length()-1);
            revS.insert(0,'-');
        }
        String newS=revS.toString();
        long val=Long.parseLong(newS);
        if(val<MIN_VAL ||val>MAX_VAL)
        {
            return 0;
        }
        return (int)val;
    }
}
//SC:O(N)
//TC:O(N)//Approach 2
*/
class Solution {    
    public int reverse(int x) 
    {
        int rev=0;
        int temp=x;
        while(temp!=0)
        {
           int val= temp%10;
            if(rev<(Integer.MIN_VALUE/10)||rev>(Integer.MAX_VALUE/10))
            {
                return 0;
            }
            rev=rev*10+val;
            temp=temp/10;
        }
        return rev;
    }
}
//TC:O(log(x)) //SC:O(1)
