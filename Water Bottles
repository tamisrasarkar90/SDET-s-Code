/*
Problem Statemnet: There are numBottles water bottles that are initially full of water. You can exchange numExchange empty water bottles from the market with one full water bottle.
The operation of drinking a full water bottle turns it into an empty bottle.Given the two integers numBottles and numExchange, return the maximum number of water bottles you can drink.

Example 1:
Input: numBottles = 9, numExchange = 3
Output: 13
Explanation: You can exchange 3 empty bottles to get 1 full water bottle.
Number of water bottles you can drink: 9 + 3 + 1 = 13.

Example 2:
Input: numBottles = 15, numExchange = 4
Output: 19
Explanation: You can exchange 4 empty bottles to get 1 full water bottle. 
Number of water bottles you can drink: 15 + 3 + 1 = 19.
 
Constraints:
1 <= numBottles <= 100
2 <= numExchange <= 100
 
*/
class Solution {
    public int numWaterBottles(int numBottles, int numExchange) 
    {
        //Approach 3
        //for each time from numBottles,numExchange-1 is getting removed, so the result is numBottles+extraBottles, where extraBottles=numBottles-1/numExchange-1;
        int extraBottles=(numBottles-1)/(numExchange-1);
        return numBottles+extraBottles;
    }
}
//TC:O(1)//SC:O(1)

        //Approcah 2
        int consume=numBottles; //Lets assumen we consume all numBottles first
        int emptyBottle=numBottles; //so these are emptybotteles now
        while(emptyBottle>=numExchange)
        {
            int extraFullBottles=emptyBottle/numExchange;
            consume+=extraFullBottles;
            int reminder=emptyBottle%numExchange;
            emptyBottle=reminder+extraFullBottles;
        }

        return consume;
    }
}
//TC:O(logN)

        
        //Approach 1
        int consume=0;
        while(numBottles>=numExchange)
        {
            consume+=numExchange;
            numBottles-=numExchange;
            numBottles+=1;
        }
        return consume+numBottles;
    }
}
//TC:O(N)
//SC:O(1)
