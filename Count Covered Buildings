/*
Problem Statement:: You are given a positive integer n, representing an n x n city. You are also given a 2D grid buildings, where buildings[i] = [x, y] denotes a unique building located at coordinates [x, y].
A building is covered if there is at least one building in all four directions: left, right, above, and below.Return the number of covered buildings.

Example 1:
Input: n = 3, buildings = [[1,2],[2,2],[3,2],[2,1],[2,3]]
Output: 1
Explanation:
Only building [2,2] is covered as it has at least one building:
above ([1,2])
below ([3,2])
left ([2,1])
right ([2,3])
Thus, the count of covered buildings is 1.
Example 2:
Input: n = 3, buildings = [[1,1],[1,2],[2,1],[2,2]]
Output: 0
Explanation:
No building has at least one building in all four directions.
Example 3:
Input: n = 5, buildings = [[1,3],[3,2],[3,3],[3,5],[5,3]]
Output: 1
Explanation:
Only building [3,3] is covered as it has at least one building:
above ([1,3])
below ([5,3])
left ([3,2])
right ([3,5])
Thus, the count of covered buildings is 1.

Constraints:
2 <= n <= 105
1 <= buildings.length <= 105 
buildings[i] = [x, y]
1 <= x, y <= n
All coordinates of buildings are unique.
*/
class Solution {
    public int countCoveredBuildings(int n, int[][] buildings) 
    {
        int result=0;
        Map<Integer,TreeSet<Integer>> rowToCol=new HashMap();
        Map<Integer,TreeSet<Integer>> colToRow=new HashMap();
        for(int[]b:buildings)
        {
            int x=b[0];
            int y=b[1];
            rowToCol.computeIfAbsent(x,k->new TreeSet()).add(y); //If key value if empty then create a new TreeSet else add onto the existing Treeset
            colToRow.computeIfAbsent(y,k->new TreeSet()).add(x); 
        }
    //TC: To fill map-> TC:O(N) and to fill TreeSet TC->O(log(N))

        for(int[]b:buildings)
        {
            int x=b[0];
            int y=b[1];
            Integer down=colToRow.get(y).higher(x);
            Integer up=colToRow.get(y).lower(x);
            Integer left=rowToCol.get(x).lower(y);
            Integer right=rowToCol.get(x).higher(y);

            if (left != null && right != null && up != null && down != null)
            {
               result++;
            }
    }
        return result;  
    }
}
//Similarly in the above iteration to iterate on buildings-> TC:O(N) and to get higher and lower value from treeSet TC:O(logN)

//TC:O(Nlog(N))
//SC:O(N)
/*
Approach: We need such points in order to find covered building is(mostly diagonal), that's there is point on left and right for same row value and up and down for same col value
Now inorder to find such point, for each point as key will create rowMap and colMap repecpectively, where the value corresponds to the key would be a TreeSet(Inorder to find min/max(or left/right point)),
will check for any given row vlaue there exists left value of y(colvalue) and right value of y and for any colvalue there exists up and down value as row then that's a covered point, will increase the count and return count as result

*/


*/
