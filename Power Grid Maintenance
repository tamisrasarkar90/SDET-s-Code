/*
Problem Statement: You are given an integer c representing c power stations, each with a unique identifier id from 1 to c (1‑based indexing).These stations are interconnected via n bidirectional cables, represented by a 2D array connections, where each element connections[i] = [ui, vi] indicates a connection between station ui and station vi. Stations that are directly or indirectly connected form a power grid.
Initially, all stations are online (operational).You are also given a 2D array queries, where each query is one of the following two types:
[1, x]: A maintenance check is requested for station x. If station x is online, it resolves the check by itself. If station x is offline, the check is resolved by the operational station with the smallest id in the same power grid as x. If no operational station exists in that grid, return -1.
[2, x]: Station x goes offline (i.e., it becomes non-operational).
Return an array of integers representing the results of each query of type [1, x] in the order they appear.
Note: The power grid preserves its structure; an offline (non‑operational) node remains part of its grid and taking it offline does not alter connectivity.
Example 1:
Input: c = 5, connections = [[1,2],[2,3],[3,4],[4,5]], queries = [[1,3],[2,1],[1,1],[2,2],[1,2]]
Output: [3,2,3]
Explanation:
Initially, all stations {1, 2, 3, 4, 5} are online and form a single power grid.
Query [1,3]: Station 3 is online, so the maintenance check is resolved by station 3.
Query [2,1]: Station 1 goes offline. The remaining online stations are {2, 3, 4, 5}.
Query [1,1]: Station 1 is offline, so the check is resolved by the operational station with the smallest id among {2, 3, 4, 5}, which is station 2.
Query [2,2]: Station 2 goes offline. The remaining online stations are {3, 4, 5}.
Query [1,2]: Station 2 is offline, so the check is resolved by the operational station with the smallest id among {3, 4, 5}, which is station 3.
Example 2:
Input: c = 3, connections = [], queries = [[1,1],[2,1],[1,1]]
Output: [1,-1]
Explanation:
There are no connections, so each station is its own isolated grid.
Query [1,1]: Station 1 is online in its isolated grid, so the maintenance check is resolved by station 1.
Query [2,1]: Station 1 goes offline.
Query [1,1]: Station 1 is offline and there are no other stations in its grid, so the result is -1.
 
Constraints:
1 <= c <= 105
0 <= n == connections.length <= min(105, c * (c - 1) / 2)
connections[i].length == 2
1 <= ui, vi <= c
ui != vi
1 <= queries.length <= 2 * 105
queries[i].length == 2
queries[i][0] is either 1 or 2.
1 <= queries[i][1] <= c

*/
class Solution {
    Map<Integer,TreeSet<Integer>> map=new HashMap<>();
    public void dfs(int node, Map<Integer,List<Integer>> adj,int[]visited,int node_ID,int[]componentId) //TC:O(V+E)[which is DFS TC]
    {
        visited[node]=1;
        componentId[node]=node_ID;
        map.putIfAbsent(node_ID,new TreeSet<>());
        map.get(node_ID).add(node);
       //now recussively call dfs for all neighbours node
        for(int neighbours:adj.getOrDefault(node,new ArrayList<>()))
        {
            if(visited[neighbours]==0)
            {
                dfs(neighbours,adj,visited,node_ID,componentId);
            }
        }
         
    }

    public int[] processQueries(int c, int[][] connections, int[][] queries) //For queries processing Q*log(c)=> log(c) to remove from the set
    {
        Map<Integer,List<Integer>> adj=new HashMap();
        for(int[] edge:connections)
        {
           int u= edge[0];
           int v= edge[1];
           adj.computeIfAbsent(u,k->new ArrayList<>()).add(v);
           adj.computeIfAbsent(v,k->new ArrayList<>()).add(u);
        }
        int[] visited=new int[c+1];
        int[] componentId=new int[c+1];
        for(int node=1;node<=c;node++)
        {
            int _id=node;
            if(visited[node]==0)
            {
                dfs(node,adj,visited,_id,componentId);
            }
        }
        //Process the query
        List<Integer> result=new ArrayList();
        for(int[] query:queries)
        {
            int state=query[0];
            int node_Number=query[1];
            // groupID is the key of the map and against it there is a Set of elements/nodes those which belongs to same groupID
            int groupID= componentId[node_Number]; 
            TreeSet<Integer> tset=map.get(groupID);
            if(state==1) //then first check if the node exists in the set of the map as val, if exists then add it directly to the result,or else take the first node from the TreeSet(check if TreeSet size is greater than 0)
            {
               if(tset.contains(node_Number))
               {
                 result.add(node_Number);
               }
               else if(tset.size()>=1)
               {
                 result.add(tset.first());
               }
               else
               {
                result.add(-1);
               }
            }
            else //if state =2, then remove the node from the map as it is now offline
            {
               tset.remove(node_Number);
            }

        }
        int[] finalRes=new int[result.size()];
        for(int i=0;i<result.size();i++)
        {
            finalRes[i]=result.get(i);
        }
        return finalRes;
    }
}
//TC:O(V+E)=> TC:O(c+n)*Q(log(c))

/*
Approach: Here what we are doing is, we are first creating adjlist for graph representations of nodes and vertices, now will divide entireconnections node into some groups those are connected belongs to same group and if not connected then different group
for that will create another map whose key is this groupId and values is OrderedSet which we need in order to keep track the next near nodes once node becomes offline. and will create another array as componentId which will keep track of this nodes and groupID mapping(like for those nodes belongs to same group will have same number as groupId(suppose1)and those nodes are in different geoups will have different componentId as values and index as nodeNumber!
Now for each node will run a dfs will group then accordingly and insert into the map and mark visited
For query processing, will get the state, if state is 2 and thenode belongs to the corresponsing TreeSet as val of  a particular compeenetId as key then will remove that node as it simply Offline, or else if status =1, then if the node belongs to theat set will add directly to the result, or else if not belongs to the set or already remove then will take the forst component from the Treeset which is sorted and would consider a steh nearest node and add it to the result will check incase the treeset is not null,
if null then will add -1 to the result.

*/
