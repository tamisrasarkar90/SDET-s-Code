/*
Problem Description: 
On day 1, one person discovers a secret.You are given an integer delay, which means that each person will share the secret with a new person every day, starting from delay days after discovering the secret. You are also given an integer forget, which means that each person will forget the secret forget days after discovering it. A person cannot share the secret on the same day they forgot it, or on any day afterwards.
Given an integer n, return the number of people who know the secret at the end of day n. Since the answer may be very large, return it modulo 109 + 7.

Example 1:
Input: n = 6, delay = 2, forget = 4
Output: 5
Explanation:
Day 1: Suppose the first person is named A. (1 person)
Day 2: A is the only person who knows the secret. (1 person)
Day 3: A shares the secret with a new person, B. (2 people)
Day 4: A shares the secret with a new person, C. (3 people)
Day 5: A forgets the secret, and B shares the secret with a new person, D. (3 people)
Day 6: B shares the secret with E, and C shares the secret with F. (5 people)

Example 2:
Input: n = 4, delay = 1, forget = 3
Output: 6
Explanation:
Day 1: The first person is named A. (1 person)
Day 2: A shares the secret with B. (2 people)
Day 3: A and B share the secret with 2 new people, C and D. (4 people)
Day 4: A forgets the secret. B, C, and D share the secret with 3 new people. (6 people)
 
Constraints:
2 <= n <= 1000
1 <= delay < forget <= n

*/
class Solution {

/* solve function will evalute on day="day" how many people knows the screat, and the range  belongs from (day-forget+1 to day-delay) as from the ex 1 in the question, on day 6 those people will contribute who knows the screat on day4(as day 5 people will need 1 day delay to share the secreat), and those who are from day 2/day1 will eventually not able to contribute on day 6 as they will forget, only those people knows the screat on day 3 and day 4 are able to contribute on day6, then we sum it up.

And to evalute the result we need to sum up those subproble(which is return by solve functions) as well, like solve function will gives us how many people knows the screat on day 3 and day4 now to add day3 and day4 to get totaresult;
Why recursion, as we have similar subproblem(for day3 & day4) to add up to total result
 Approach 1: Recursion with Top down memorization: TC:O(N*(forget-delay)) and SC:O(N)
*/
    int M=1000000007;
    public int peopleAwareOfSecret(int n, int delay, int forget) 
    {
       int[] dp=new int[n+1];
       //to evaluate total numbers of persons know the screat till day n
       int totalNoOfPeople=0;
       Arrays.fill(dp,-1);
       for(int d=n-forget+1;d<=n;d++)
       {
         if(d>0)
         {
             totalNoOfPeople=(totalNoOfPeople+solve(d,forget,delay,dp))%M;
         }       
       }
       return totalNoOfPeople; 
    }
    //This function returns how many number of people know the screat on the day "day"
    private int solve(int day,int forget,int delay,int[]dp)
    {
           if(day==1)
           {
             return 1;
           }
           if(day<=0)
           {
            return 0;
           }
           if(dp[day]!=-1)
           {
            return dp[day];
           }
        long result=0;       
        for(int prev=day-forget+1;prev<=day-delay;prev++)
        {
            if(prev>0)
            {
                 result= (result+solve(prev,forget,delay,dp))%M;
            }          
        }      
        return dp[day]=(int)result;
    }
}
