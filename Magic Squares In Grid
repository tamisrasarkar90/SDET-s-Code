/*
Problem Description:  A 3 x 3 magic square is a 3 x 3 grid filled with distinct numbers from 1 to 9 such that each row, column, and both diagonals all have the same sum.
Given a row x col grid of integers, how many 3 x 3 magic square subgrids are there?Note: while a magic square can only contain numbers from 1 to 9, grid may contain numbers up to 15.

Example 1:
Input: grid = [[4,3,8,4],[9,5,1,9],[2,7,6,2]]
Output: 1
Explanation: 
The following subgrid is a 3 x 3 magic square:
while this one is not:In total, there is only one magic square inside the given grid.
Example 2:
Input: grid = [[8]]
Output: 0
 
Constraints:
row == grid.length
col == grid[i].length
1 <= row, col <= 10
0 <= grid[i][j] <= 15
*/
class Solution {
    public int numMagicSquaresInside(int[][] grid) 
    {
        int m=grid.length;
        int n=grid[0].length;
        int count=0;
        for(int r=0;r<m-2;r++)
        {
            for(int c=0;c<n-2;c++)
            {
               if(isValid(r,c,grid))
               {
                 count+=1;
               }
            }
        }
        return count;
    }
    private static boolean isValid(int r,int c,int[][]grid)
    {
        Set<Integer> set=new HashSet();
        //This is to check number is within 1-9 and no duplicate
        for(int i=0;i<3;i++)
        {
            for(int j=0;j<3;j++)
            {
               int num=grid[r+i][c+j];
               if(num<1 || num>9 || set.contains(num))
               {
                return false;
               }
               set.add(num);
            }
        }
        int sum=grid[r][c]+grid[r][c+1]+grid[r][c+2];
        //Chcek if row and col sum equals
        for(int i=0;i<3;i++)
        {
            //check all row sum
            if(grid[r+i][c]+grid[r+i][c+1]+grid[r+i][c+2]!=sum)
            {
                return false;
            }
            //check all col
            if(grid[r][c+i]+grid[r+1][c+i]+grid[r+2][c+i]!=sum)
            {
                return false;
            } 
        }
        //Check for diagonal
        if(grid[r][c]+grid[r+1][c+1]+grid[r+2][c+2]!=sum)
        {
            return false;
        }
        //Check for antidiagonal
        if(grid[r][c+2]+grid[r+1][c+1]+grid[r+2][c]!=sum)
        {
            return false;
        }
       return true;
    }
}
//TC:O(M*N)
//SC:O(N) //set size
